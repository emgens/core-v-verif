(VIssue Interface
p0
ccopy_reg
_reconstructor
p1
(cvp_pack
Ip
p2
c__builtin__
object
p3
Ntp4
Rp5
(dp6
Vprop_count
p7
I9
sVname
p8
g0
sVprop_list
p9
(dp10
sVip_num
p11
I0
sVwid_order
p12
I0
sVrfu_dict
p13
(dp14
sVrfu_list
p15
(lp16
(V000_issue_req signals stable
p17
g1
(cvp_pack
Prop
p18
g3
Ntp19
Rp20
(dp21
Vitem_count
p22
I1
sg8
g17
sVtag
p23
VVP_CVXIF_F000_S000
p24
sVitem_list
p25
(dp26
sg12
I0
sg15
(lp27
(V000
p28
g1
(cvp_pack
Item
p29
g3
Ntp30
Rp31
(dp32
g8
V000
p33
sg23
VVP_CVXIF_F000_S000_I000
p34
sVdescription
p35
VThe \u201cinstr\u201d and \u201cmode\u201d signals remain stable during an Issue request transaction.
p36
sVpurpose
p37
V
p38
sVverif_goals
p39
VCheck that \u201cmode\u201d and \u201cinstr\u201d are stable during an issue transaction (cannot be modified by an instruction when transaction issue is in process)
p40
sVcoverage_loc
p41
g38
sVref_mode
p42
Vpage
p43
sVref_page
p44
g38
sVref_section
p45
g38
sVref_viewer
p46
Vfirefox
p47
sVpfc
p48
I4
sVtest_type
p49
I3
sVcov_method
p50
I2
sVcores
p51
I56
sVcomments
p52
g38
sVstatus
p53
g38
sVsimu_target_list
p54
(lp55
sg15
(lp56
sVrfu_list_2
p57
(lp58
sg13
(dp59
Vlock_status
p60
I0
ssbtp61
asVrfu_list_1
p62
(lp63
sg57
(lp64
sg13
(dp65
sbtp66
a(V001_mode signal value
p67
g1
(g18
g3
Ntp68
Rp69
(dp70
g22
I2
sg8
g67
sg23
VVP_CVXIF_F000_S001
p71
sg25
(dp72
sg12
I1
sg15
(lp73
(V000
p74
g1
(g29
g3
Ntp75
Rp76
(dp77
g8
V000
p78
sg23
VVP_CVXIF_F000_S001_I000
p79
sg35
VWhen issue transaction starts, instruction and current CPU mode are provided
p80
sg37
g38
sg39
VCheck that a mode modification coming from execution of a first instruction is well provided to the following offloaded instruction
p81
sg41
g38
sg42
g43
sg44
g38
sg45
g38
sg46
g47
sg48
I3
sg49
I3
sg50
I1
sg51
I56
sg52
g38
sg53
g38
sg54
(lp82
sg15
(lp83
sg57
(lp84
sg13
(dp85
g60
I0
ssbtp86
a(V001
p87
g1
(g29
g3
Ntp88
Rp89
(dp90
g8
V001
p91
sg23
VVP_CVXIF_F000_S001_I001
p92
sg35
VCheck \u201cmode\u201d signal values.
p93
sg37
g38
sg39
VCheck that mode take a value that the CPU supports : Privilege level (2\u2019b00 = User, 2\u2019b01 = Supervisor, 2\u2019b10 = Reserved,\u000a 2\u2019b11 = Machine).
p94
sg41
g38
sg42
g43
sg44
g38
sg45
g38
sg46
g47
sg48
I-1
sg49
I-1
sg50
I-1
sg51
I56
sg52
g38
sg53
g38
sg54
(lp95
sg15
(lp96
sg57
(lp97
sg13
(dp98
g60
I0
ssbtp99
asg62
(lp100
sg57
(lp101
sg13
(dp102
sbtp103
a(V002_rs_valid signal transition order
p104
g1
(g18
g3
Ntp105
Rp106
(dp107
g22
I1
sg8
g104
sg23
VVP_CVXIF_F000_S002
p108
sg25
(dp109
sg12
I2
sg15
(lp110
(V000
p111
g1
(g29
g3
Ntp112
Rp113
(dp114
g8
V000
p115
sg23
VVP_CVXIF_F000_S002_I000
p116
sg35
VDuring a transaction, each bit of \u201crs_valid\u201d can transition from 0 to 1 but are not allowed to transition back to 0.
p117
sg37
g38
sg39
VFor issue transaction which lasts more than one cycle, check that asserted \u201crs_valid\u201d signals do not transition back to 0.(for i in [0;2] if rs_valid[i] = 1 then rs_valid[i] \u2192 0 cannot happen)
p118
sg41
g38
sg42
g43
sg44
g38
sg45
g38
sg46
g47
sg48
I4
sg49
I3
sg50
I2
sg51
I56
sg52
g38
sg53
g38
sg54
(lp119
sg15
(lp120
sg57
(lp121
sg13
(dp122
g60
I0
ssbtp123
asg62
(lp124
sg57
(lp125
sg13
(dp126
sbtp127
a(V003_rs signal value
p128
g1
(g18
g3
Ntp129
Rp130
(dp131
g22
I3
sg8
g128
sg23
VVP_CVXIF_F000_S003
p132
sg25
(dp133
sg12
I3
sg15
(lp134
(V000
p135
g1
(g29
g3
Ntp136
Rp137
(dp138
g8
V000
p139
sg23
VVP_CVXIF_F000_S003_I000
p140
sg35
VIf XLEN = X_RFR_WIDTH, then rs[X_NUM_RS-1:0] correspond to  rs1 and rs2 CPU registers (and rs3 if X_NUM_RS = 3).
p141
sg37
g38
sg39
VFor every issue transaction check that rs signal correspond to rs1,rs2(rs3) value in CPU register file.
p142
sg41
g38
sg42
g43
sg44
g38
sg45
g38
sg46
g47
sg48
I3
sg49
I3
sg50
I1
sg51
I56
sg52
g38
sg53
g38
sg54
(lp143
sg15
(lp144
sg57
(lp145
sg13
(dp146
g60
I0
ssbtp147
a(V001
p148
g1
(g29
g3
Ntp149
Rp150
(dp151
g8
V001
p152
sg23
VVP_CVXIF_F000_S003_I001
p153
sg35
Vrs signals are only required to be stable during the part of a transaction in which these signals are considered to be valid.
p154
sg37
g38
sg39
VCheck that rs signals are stable when issue_valid==1 && the corresponding bit in rs_valid is 1.
p155
sg41
g38
sg42
g43
sg44
g38
sg45
g38
sg46
g47
sg48
I4
sg49
I-1
sg50
I2
sg51
I56
sg52
g38
sg53
g38
sg54
(lp156
sg15
(lp157
sg57
(lp158
sg13
(dp159
g60
I0
ssbtp160
a(V002
p161
g1
(g29
g3
Ntp162
Rp163
(dp164
g8
V002
p165
sg23
VVP_CVXIF_F000_S003_I002
p166
sg35
VIf XLEN != X_RFR_WIDTH , then rs[X_NUM_RS-1:0] correspond to even/odd register pair with rs1, rs2, (rs3) are even register and even register is provided in the 32 lower bits of rs signal.
p167
sg37
g38
sg39
VFor every issue transaction check that rs signal correspond to the concatenation of rs1/rs1+1,rs2/rs2+1, (rs3/rs3+1) value in CPU register file and even register is in the 32 lower bits of rs.
p168
sg41
g38
sg42
g43
sg44
g38
sg45
g38
sg46
g47
sg48
I-1
sg49
I-1
sg50
I-1
sg51
I56
sg52
g38
sg53
g38
sg54
(lp169
sg15
(lp170
sg57
(lp171
sg13
(dp172
g60
I0
ssbtp173
asg62
(lp174
sg57
(lp175
sg13
(dp176
sbtp177
a(V004_Default value for unaccepted instruction
p178
g1
(g18
g3
Ntp179
Rp180
(dp181
g22
I1
sg8
g178
sg23
VVP_CVXIF_F000_S004
p182
sg25
(dp183
sg12
I4
sg15
(lp184
(V000
p185
g1
(g29
g3
Ntp186
Rp187
(dp188
g8
V000
p189
sg23
VVP_CVXIF_F000_S004_I000
p190
sg35
VIf accept == 0 :\u000aWriteback == 0; dualwrite == 0; dualread == 0; loadstore == 0; exc = 0.
p191
sg37
g38
sg39
VCheck that for writeback; dualwrite; dualread; loadstore; exc signals if accept == 0 then all those signals are 0.
p192
sg41
g38
sg42
g43
sg44
g38
sg45
g38
sg46
g47
sg48
I4
sg49
I3
sg50
I2
sg51
I56
sg52
g38
sg53
g38
sg54
(lp193
sg15
(lp194
sg57
(lp195
sg13
(dp196
g60
I0
ssbtp197
asg62
(lp198
sg57
(lp199
sg13
(dp200
sbtp201
a(V005_Illegal Instruction causes
p202
g1
(g18
g3
Ntp203
Rp204
(dp205
g22
I1
sg8
g202
sg23
VVP_CVXIF_F000_S005
p206
sg25
(dp207
sg12
I5
sg15
(lp208
(V000
p209
g1
(g29
g3
Ntp210
Rp211
(dp212
g8
V000
p213
sg23
VVP_CVXIF_F000_S005_I000
p214
sg35
VThe CPU shall cause an illegal instruction if:\u000a- an instruction is considered to be valid by the CPU and accepted by the coprocessor (accept = 1)\u000a- neither to be valid by the CPU nor accepted by the coprocessor (accept = 0)
p215
sg37
g38
sg39
V- CPU causes illegal instruction for instruction accepted by the core and the coprocessor.\u000a- CPU causes illegal instruction exception for instruction that are not valid for coprocessor and CPU
p216
sg41
g38
sg42
g43
sg44
g38
sg45
g38
sg46
g47
sg48
I3
sg49
I3
sg50
I1
sg51
I56
sg52
g38
sg53
g38
sg54
(lp217
sg15
(lp218
sg57
(lp219
sg13
(dp220
g60
I0
ssbtp221
asg62
(lp222
sg57
(lp223
sg13
(dp224
sbtp225
a(V006_issue uniquness
p226
g1
(g18
g3
Ntp227
Rp228
(dp229
g22
I1
sg8
g226
sg23
VVP_CVXIF_F000_S006
p230
sg25
(dp231
sg12
I6
sg15
(lp232
(V000
p233
g1
(g29
g3
Ntp234
Rp235
(dp236
g8
V000
p237
sg23
VVP_CVXIF_F000_S006_I000
p238
sg35
VCheck for issue id validity.
p239
sg37
g38
sg39
VCheck that the issue interface doesn't issue an "id" that isn't legal to be used (has not fully completed).
p240
sg41
g38
sg42
g43
sg44
g38
sg45
g38
sg46
g47
sg48
I11
sg49
I3
sg50
I10
sg51
I56
sg52
g38
sg53
g38
sg54
(lp241
sg15
(lp242
sg57
(lp243
sg13
(dp244
g60
I0
ssbtp245
asg62
(lp246
sg57
(lp247
sg13
(dp248
sbtp249
a(V007_coprocessor decoding
p250
g1
(g18
g3
Ntp251
Rp252
(dp253
g22
I1
sg8
g250
sg23
VVP_CVXIF_F000_S007
p254
sg25
(dp255
sg12
I7
sg15
(lp256
(V000
p257
g1
(g29
g3
Ntp258
Rp259
(dp260
g8
V000
p261
sg23
VVP_CVXIF_F000_S007_I000
p262
sg35
VAccept = 1 if: \u000a- coprocessor can handle the instruction based on decoding \u201cinstr\u201dand "mode".\u000a- \u201cissue_valid\u201d == 1 and required bit(s) of \u201crs_valid\u201d are 1.
p263
sg37
g38
sg39
VTo be checked in coprocessor.
p264
sg41
g38
sg42
g43
sg44
g38
sg45
g38
sg46
g47
sg48
I3
sg49
I3
sg50
I1
sg51
I56
sg52
g38
sg53
g38
sg54
(lp265
sg15
(lp266
sg57
(lp267
sg13
(dp268
g60
I0
ssbtp269
asg62
(lp270
sg57
(lp271
sg13
(dp272
sbtp273
a(V008_Transaction definition
p274
g1
(g18
g3
Ntp275
Rp276
(dp277
g22
I1
sg8
g274
sg23
VVP_CVXIF_F000_S008
p278
sg25
(dp279
sg12
I8
sg15
(lp280
(V000
p281
g1
(g29
g3
Ntp282
Rp283
(dp284
g8
V000
p285
sg23
VVP_CVXIF_F000_S008_I000
p286
sg35
V\u201cissue_resp\u201d signals and \u201cissue_req\u201d signals are accepted when \u201cissue_valid\u201d == \u201cissue_ready\u201d == 1\u000a\u201cissue_resp\u201d is valid when "valid==ready==1".\u000a\u201cissue_req\u201d is valid when "valid==1"
p287
sg37
g38
sg39
VThe definition of a transaction. \u000aNot to be verified.
p288
sg41
g38
sg42
g43
sg44
g38
sg45
g38
sg46
g47
sg48
I11
sg49
I10
sg50
I10
sg51
I56
sg52
g38
sg53
g38
sg54
(lp289
sg15
(lp290
sg57
(lp291
sg13
(dp292
g60
I0
ssbtp293
asg62
(lp294
sg57
(lp295
sg13
(dp296
sbtp297
asVrfu_list_0
p298
(lp299
sg62
(lp300
sVvptool_gitrev
p301
V$Id: a782de3eec3de5ff99661fb165c09f541b4228d0 $
p302
sVio_fmt_gitrev
p303
V$Id: 2f6f9e7bc800d8b831382463dc706473c6c6ad8c $
p304
sVconfig_gitrev
p305
V$Id: 0422e19126dae20ffc4d5a84e4ce3de0b6eb4eb5 $
p306
sVymlcfg_gitrev
p307
V$Id: 286c689bd48b7a58f9a37754267895cffef1270c $
p308
sbtp309
.